**Building a clone of sqlite from scratch in order to understand how does a database work.**


Reading the [blog](https://cstack.github.io/db_tutorial/)

The SQLite has a documentation for your architecture on their [website](https://www.sqlite.org/arch.html)



## Notes

A query goes through a chain of components in order to retrieve or modify data. The front-end consists of the:

- **tokenizer**
- **parser**
- **code generator**

The input to the front-end is a SQL query. the output is sqlite virtual machine bytecode (essentially a compiled program that can operate on the database).

The back-end consists of the:

- **virtual machine**
- **B-tree**
- **pager**
- **OS interface**

The virtual machine takes bytecode** generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.

**Bytecode: Bytecode is computer object code that an interpreter converts into binary machine code so it can be read by a computer's hardware processor


Each B-tree consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager.


The pager receives commands to read or write pages of data. It is responsible for reading/writing
at appropriate offsets in the database file.
It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.


The pager receives commands to read or write pages of data. It is responsible for reading/writing at appropriate
offsets in the database file. It also keeps a cache of recently-accessed pages in memory,
and determines when those pages need to be written back to disk.


We’re making a clone of sqlite. The “front-end” of sqlite is a SQL compiler that parses a string and outputs an internal representation called bytecode.

This bytecode is passed to the virtual machine, which executes it.

Breaking things into two steps like this has a couple advantages:

Reduces the complexity of each part (e.g. virtual machine does not worry about syntax errors)
Allows compiling common queries once and caching the bytecode for improved performance

Non-SQL statements like .exit are called “meta-commands”. They all start with a dot, so we check for them and handle them in a separate function.

Next, we add a step that converts the line of input into our internal representation of a statement. This is our hacky version of the sqlite front-end.

Lastly, we pass the prepared statement to execute_statement. This function will eventually become our virtual machine.